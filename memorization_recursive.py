import time
import sys

sys.setrecursionlimit(13000) #ensures that the code doesn't encounter a recursion error for larger values of n.
preCalculatedList=[0, 1] #the memorization technique is used to boost the performance of the recursive function

def F(n):
    if n == 0 or n == 1: #The function checks if n is 0 or 1. In these cases, it immediately returns the value n.
        return n
    elif n < len(preCalculatedList): #If n is within the range of the pre-calculated Fibonacci numbers, it exists in the preCalculatedList, the function retrieves and returns the value from the preCalculatedList.
        return preCalculatedList[n]
    else: #If n is beyond the pre-calculated range, the function recursively calculates F(n-1)+F(n-2) and stores the result in nth_Fibonacci_Number. It appends nth_Fibonacci_Number to the preCalculatedList for future use and returns nth_Fibonacci_Number.
        nth_Fibonacci_Number = F(n - 1) + F(n - 2)
        preCalculatedList.append(nth_Fibonacci_Number) #it is stored in the preCalculatedList for future use. This avoids redundant calculations for the same value and improves performance.
        return nth_Fibonacci_Number

start_time = time.time()
print(F(10000)) #chosen nth Fibonacci number 
end_time = time.time()
execution_time = end_time - start_time
print("Execution Time:", execution_time, "seconds")

#results required
#F(0)=0
#F(1)=1
#F(2)=1 
#F(3)=2
#F(10)=55
#F(100)=354224848179261915075
#F(1000)=43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875
#F(10000)=33644764876431783266621612005107543310302148460680063906564769974680081442166662368155595513633734025582065332680836159373734790483865268263040892463056431887354544369559827491606602099884183933864652731300088830269235673613135117579297437854413752130520504347701602264758318906527890855154366159582987279682987510631200575428783453215515103870818298969791613127856265033195487140214287532698187962046936097879900350962302291026368131493195275630227837628441540360584402572114334961180023091208287046088923962328835461505776583271252546093591128203925285393434620904245248929403901706233888991085841065183173360437470737908552631764325733993712871937587746897479926305837065742830161637408969178426378624212835258112820516370298089332099905707920064367426202389783111470054074998459250360633560933883831923386783056136435351892133279732908133732642652633989763922723407882928177953580570993691049175470808931841056146322338217465637321248226383092103297701648054726243842374862411453093812206564914032751086643394517512161526545361333111314042436854805106765843493523836959653428071768775328348234345557366719731392746273629108210679280784718035329131176778924659089938635459327894523777674406192240337638674004021330343297496902028328145933418826817683893072003634795623117103101291953169794607632737589253530772552375943788434504067715555779056450443016640119462580972216729758615026968443146952034614932291105970676243268515992834709891284706740862008587135016260312071903172086094081298321581077282076353186624611278245537208532365305775956430072517744315051539600905168603220349163222640885248852433158051534849622434848299380905070483482449327453732624567755879089187190803662058009594743150052402532709746995318770724376825907419939632265984147498193609285223945039707165443156421328157688908058783183404917434556270520223564846495196112460268313970975069382648706613264507665074611512677522748621598642530711298441182622661057163515069260029861704945425047491378115154139941550671256271197133252763631939606902895650288268608362241082050562430701794976171121233066073310059947366875
"""time complexity analysis:
When the Fibonacci number at index n is not present in the preCalculatedList, the function performs a recursive calculation to find it and allocate it in the list for future use 
The recursive calls follow the Fibonacci sequence, meaning the number of recursive calls grows linearly with the input n.
The preCalculatedList operations (retrieval and appending) have a constant time complexity and do not affect the overall time complexity.
due to the memorization technique used, the time complexity of the code is O(n) which makes it more efficient than the original recursive code with a time complexity of O(2^n).
F(10000)=0.01513361930847168 s
"""